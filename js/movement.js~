//Movement mixins

//Entity can move to unblocked squares
//Takes argument in absolute coordinates to current position
Game.Mixins.AbsMoveable = {
	name : 'AbsMoveable',
	groupName : 'Moveable',
	tryMove: function(x,y,map) {
		var tile = map.getTile(x,y);
		if (tile.isWalkable() && !this._map.getEntityAt(x,y)) {
			this._x = x;
			this._y = y;

			if (this._playercontrolled) {
				this._map.getEngine().unlock();
			}

			return true;
		}
		else { return false;}
	}
}

//Has balance statistic that governs whether various actions can be used
Game.Mixins.Balanced = {
	name : 'Balanced',
	groupName : 'Balanced',
	init : function(properties) {
		this._mbal = properties['mbal'] || 5; //Max balance
		this._cbal = properties['cbal'] || 5; //Current balance
	},
	getBalance : function() {
		return this._cbal;
	},
	setBalance : function(balance) {
		this._cbal = balance;
	},
	reduceBalance : function(reduction) {
		var bal = Math.max(0,this._cbal-reduction);
		this._cbal = Math.min(this._mbal, bal);
		if (this._cbal == 1) {
			Game.sendMessage(this, "Your intricate dance is getting your legs into quite a tangle");
		}
		if (this._cbal == 0) {
			Game.sendMessage(this, "You fall over");
		}
	},
	increaseBalance : function(increase) {
		var bal = Math.min(this._mbal,this._cbal+increase);
		this._cbal = Math.max(bal,0);
	}
}

//Coordinates are relative to current position and direction
//'Fpsmove' direction is relative to current directin
//'RogueMove' direction is absolute
Game.Mixins.DirectionMoveable = {
	name : 'DirectionMoveable',
	groupName : 'Moveable',
	init : function(properties) {
		var x = properties['x_dir'] || 1;
		var y = properties['y_dir'] || -1;
		
		this._turnMode = 0;
		this._direction = v2d(x,-y);
		this._olddirection = this._direction;
		this._chararray = properties['chararray'] || Game.Chars.SingleArrows;
		this._char = this._chararray[this._direction];
	},
	getChar : function() {
		return this._chararray[this._direction];
	},
	turn : function(direction,temp) {
		if (this.getBalance()) {
			this._direction = direction;
			if (!temp) {
				this._olddirection = this._direction;
			}
			return true;
		} else {
			return false;
		}
	},

	// Move to position x, y, dir
	tryMoveTo : function(x, y, rel_dir, final_dir, map) {
		var tile = map.getTile(x,y);
		var target = this._map.getEntityAt(x,y);

		if (tile.isWalkable() && (!target || target == this)) {
			this.turn(final_dir,0);

			if (!this.getBalance()) {
				Game.sendMessage(this,'You stand on shaking legs, steadying yourself to step once more.');
				this.setBalance(2);
				return true;
			} else {
				var bal_loss = Math.min(1,mod(rel_dir,7)-1);
				this.reduceBalance(bal_loss);
				this._x = x;
				this._y = y;
			}
			
		} else {
			return false;
		}
		
	},
	
	tryWait : function(final_dir, map) {
		this.increaseBalance(2);
		this._direction = final_dir;
		this._olddirection = final_dir;
		return true;
	},

	fpsMove : function(dx,dy,map) {

		if (dx == 0 && dy == 0) {
			return this.tryWait(this._direction, this.getMap());
		}


		var rel_dir = v2d(dx,dy);
		var move_dir = mod(this._direction-rel_dir,8);
		var move_vec = d2v(move_dir);
		var x = move_vec[0]+this.getX();
		var y = move_vec[1]+this.getY();

		return this.tryMoveTo(x, y, rel_dir, this._direction, this.getMap());

	},


	kbMove: function(dx,dy,noturn,map) {


		if (this._turnMode) {
			this._turnMode = 0;
			final_dir = v2d(dx,-dy);
			return this.tryWait(final_dir, this.getMap());
		}

		if (dx == 0 && dy == 0) {
			return this.tryWait(this._direction, this.getMap());
		}

		var x = this.getX() + dx;
		var y = this.getY() + dy;
		
		if (!noturn) {
			var final_dir = v2d(dx,-dy);
			var rel_dir = 0;
		} else {
			var final_dir = this._direction;
			var rel_dir = mod(this._direction - v2d(dx,-dy),8);
		}

		return this.tryMoveTo(x, y, rel_dir, final_dir, this.getMap());

	}
}
